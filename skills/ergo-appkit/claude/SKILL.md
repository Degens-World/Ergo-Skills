---
name: ergo-appkit-code-generator
description: "Generates boilerplate Java code for common tasks using the Ergo Appkit library, such as creating transactions, connecting to a node, and issuing tokens."
---

# Ergo Appkit Code Generator

Generates boilerplate Java code for common tasks using the Ergo Appkit library, such as creating transactions, connecting to a node, and issuing tokens.


# Ergo Appkit Code Generator Skill

## 1. Overview

Ergo Appkit is a powerful Java-based library for building applications on the Ergo blockchain. It provides a high-level API that simplifies interaction with Ergo nodes, creating and signing transactions, and managing wallets. This skill acts as a code generation assistant, helping developers quickly produce boilerplate code for common Appkit use cases, significantly reducing development time and lowering the barrier to entry for building on Ergo.

By providing a set of commands and parameters, developers can generate production-ready Java code snippets that handle node connections, transaction creation, token issuance, and more. This accelerates development time and reduces common errors by providing a well-structured and tested code foundation. The generated code is designed to be easily integrated into existing Java, Scala, or Kotlin projects.

### Key Use Cases:
- **Connecting to an Ergo Node**: Generate configuration code for `ErgoClient` to connect to different network types (Mainnet, Testnet), providing an instant starting point for any application.
- **Creating Standard Transactions**: Build code for P2PK (Pay-to-Public-Key) transactions to send ERG, including box selection, fee calculation, and change management.
- **Issuing New Tokens**: Generate the logic for creating (minting) a new native token on the Ergo platform, adhering to the EIP-4 standard.
- **Signing Transactions**: Create code demonstrating how to use an `ErgoProver` to sign transactions with a given mnemonic, with a strong emphasis on secure key handling.

This documentation will guide you through the architecture of the generated code, project setup requirements, and detailed usage of each available command.

--- 

## 2. Architecture of Generated Code

The code generated by this skill follows the fundamental architectural patterns of Ergo Appkit, ensuring best practices and compatibility.

1.  **ErgoClient**: This is the main entry point for interacting with an Ergo node. It's used to access the blockchain state through a `BlockchainContext`. The generated code will show how to instantiate an `ErgoClient` for a specific node URL and network type, handling the initial connection logic.

2.  **BlockchainContext (`ctx`)**: The `BlockchainContext` is obtained from the `ErgoClient` and represents a snapshot of the blockchain state at a specific block height. It's a mandatory, immutable object for nearly all operations, including creating transactions, accessing blockchain data, and building provers. All generated code snippets will include obtaining a `ctx` object within an `execute` block, which safely manages the client's resources.

3.  **Transaction Building**: Ergo transactions are built by defining output boxes (`OutBox`) and selecting input boxes (UTXOs) to cover the required ERG amount and transaction fees. The generated code simplifies this by:
    *   Creating an `ErgoContract` for the recipient from their address.
    *   Building an `OutBox` with the specified ERG value and the recipient's contract.
    *   Using the `BoxOperations` helper class to automatically find and select suitable input boxes from a given wallet address. This helper also intelligently creates a "change" output box to return unspent ERG and tokens back to the sender.
    *   Instantiating an `UnsignedTransaction` object ready for signing.

4.  **Transaction Signing (`ErgoProver`)**: To spend funds, an `UnsignedTransaction` must be signed by a prover that holds the corresponding private keys. This is handled by an `ErgoProver`.
    *   A prover is built using a wallet's mnemonic phrase and an optional password.
    *   The `prover.sign(unsignedTx)` method validates the transaction against the prover's context and secrets, producing a cryptographically secure `SignedTransaction`.
    *   Generated code will clearly show how to instantiate a prover. **Crucially**, it uses a placeholder for the mnemonic, emphasizing that real secrets must be loaded securely at runtime.

5.  **Submitting Transactions**: Once a transaction is signed, it can be submitted to the blockchain using `ctx.sendTransaction(signedTx)`. The node then broadcasts it to the network for inclusion in the next block. The generated code returns the transaction ID, which can be used to track its status on a block explorer.

Below is a diagram illustrating the typical flow:

```
[Developer App] -> [ErgoClient] -> [Ergo Node]
      |
      V
[BlockchainContext] -> [Transaction Builder (BoxOperations)]
      |
      V
[ErgoProver] -> [Sign Transaction] -> [Submit to Node]
```

--- 

## 3. Setup and Dependencies

To use the code generated by this skill, you need a Java project (or another JVM language like Scala or Kotlin) with the `ergo-appkit` dependency.

### Maven Dependency

Add the following to your `pom.xml` file. Always check for the latest version on Maven Central.

```xml
<dependency>
    <groupId>org.ergoplatform</groupId>
    <artifactId>ergo-appkit</artifactId>
    <version>4.0.10</version>  <!-- Or the latest version -->
</dependency>
```

### Gradle Dependency

Add the following to your `build.gradle` file:

```groovy
dependencies {
    implementation 'org.ergoplatform:ergo-appkit:4.0.10' // Or the latest version
}
```

Ensure you have a compatible Java version (JDK 8 or newer) configured in your project.

--- 

## 4. API Reference: Commands

This skill provides several commands to generate code for different tasks. Each command has specific parameters to customize the output.

### Command: `connect_node`

Generates code to initialize an `ErgoClient` and connect to a specified Ergo node.

**Input Parameters:**

| Parameter | Type | Description |
|---|---|---|
| `node_url` | String | The URL of the Ergo node to connect to. E.g., `http://213.239.193.208:9053/` |
| `network_type` | Enum | The network type. Can be `MAINNET` or `TESTNET`. |
| `api_key` | String | The API key for authenticating with the node. Optional; an empty string is often used for public nodes. |

**Generated Code Logic:**

The output code will show how to create an `ErgoClient` instance. It demonstrates the use of a `try-with-resources` block to ensure the client is properly closed. Inside the block, it obtains a `BlockchainContext` and prints a success message with the current block height, confirming a successful connection.

### Command: `create_transaction`

Generates a complete code snippet for creating and sending a simple P2PK (Pay-to-Public-Key) transaction.

**Input Parameters:**

| Parameter | Type | Description |
|---|---|---|
| `node_url` | String | The URL of the Ergo node. |
| `network_type` | Enum | `MAINNET` or `TESTNET`. |
| `wallet_mnemonic_secret` | String | A reference to a secret (e.g., env var name) containing the sender's mnemonic. **Do not use the raw mnemonic.** |
| `sender_address`| String | The P2PK address of the sender's wallet. |
| `recipient_address` | String | The P2PK address of the recipient. |
| `send_amount_nanoergs` | Integer | The amount to send, denominated in nanoERGs (1 ERG = 1,000,000,000 nanoERGs). |

**Generated Code Logic:**

This command generates a full, runnable method that connects to the node, initializes an `ErgoProver` using the provided secret reference, defines transaction parameters, builds an `OutBox`, uses `BoxOperations` to select inputs and create change, creates an `UnsignedTransaction`, signs it, submits it to the network, and prints the resulting transaction ID.

### Command: `issue_token`

Generates code to issue a new token on the Ergo blockchain, following the EIP-4 standard.

**Input Parameters:**

| Parameter | Type | Description |
|---|---|---|
| `node_url` | String | The URL of the Ergo node. |
| `network_type` | Enum | `MAINNET` or `TESTNET`. |
| `wallet_mnemonic_secret` | String | A reference to a secret containing the issuer's mnemonic. **Do not use the raw mnemonic.** |
| `issuer_address` | String | The P2PK address of the issuer. The issued tokens will be sent here. |
| `token_name` | String | The name of the token (e.g., "MyToken"). |
| `token_description` | String | A short description of the token. |
| `token_amount`| Integer | The total supply of the token to be issued. |
| `token_decimals` | Integer | The number of decimal places for the token (0-8). |

**Generated Code Logic:**
1.  Similar to `create_transaction`, it connects to a node and sets up a prover.
2.  It builds a special `OutBox` that will be the first output of the transaction. This box will contain the newly minted tokens.
3.  This `OutBox` is minted with the new token using the `mintToken` method. The token ID is required by Ergo protocol to be the ID of the first input box of the transaction. The generated code handles this linkage.
4.  The necessary ERG value to cover the box's rent is calculated and included.
5.  The rest of the transaction flow (box selection, signing, sending) is handled by `BoxOperations` similarly to a standard transaction.

--- 

## 5. Error Handling and Troubleshooting

The generated code includes basic `try-catch` blocks, but users may encounter several common runtime issues.

- **`java.net.ConnectException`**: This occurs if the `node_url` is incorrect, the node is offline, or a firewall is blocking the connection. Double-check the URL and the node's status.

- **`"Not enough boxes to cover ERG amount"`**: This error from `BoxOperations` means the specified wallet does not have enough spendable ERG to cover the `send_amount_nanoergs` plus the transaction fee. This can be misleading; your wallet may show a balance, but the funds might be in many small "dust" boxes or locked in contracts that the simple `BoxOperations` call doesn't use. Consider a wallet consolidation transaction.

- **`ErgoValidationException`**: If a transaction is successfully built and signed but rejected by the node on submission, this exception is thrown. It contains a detailed error message from the node. Common causes include an invalid script, a double-spend attempt, or incorrect signing.

- **"API Key is not correct"**: The node may be configured to require a specific API key for certain endpoints. Ensure the `api_key` parameter is correct or that the node is truly public.
 
- **Invalid Mnemonic**: Using an incorrect mnemonic phrase will cause the prover to generate wrong addresses, fail to find wallet boxes, and produce invalid signatures. Address checksums will fail.

- **Transaction Failure Post-Submission**: A submitted transaction might fail to get included in a block if the fee is too low for current network congestion or if it conflicts with another transaction. Check a block explorer to see the status of the transaction ID.

--- 

## 6. Critical Security Guidance

### Handling Mnemonics and Private Keys

The most critical security consideration when using Appkit is the management of private keys and mnemonic phrases.

-   **NEVER hardcode secrets in your source code.** Storing mnemonics, passwords, or API keys directly in your `.java` files is extremely dangerous. If you commit this code to a public or private repository, your funds can be stolen.
-   **The `wallet_mnemonic_secret` parameter is a REFERENCE.** This skill expects you to provide a *reference* to a secret, not the secret itself. Your application's runtime environment is responsible for resolving this reference to the actual mnemonic. This is a standard pattern for secure software development.

### Recommended Security Patterns

1.  **Environment Variables**: This is the simplest secure method. Store your mnemonic in an environment variable on the server or machine running the code.
    ```java
    // Your application code resolves the reference passed by the skill
    String mnemonic = System.getenv("MY_WALLET_MNEMONIC_ENV_VAR");
    if (mnemonic == null) {
        throw new RuntimeException("Mnemonic environment variable not set!");
    }
    SecretString mnemonicSecret = SecretString.create(mnemonic);
    // ... use mnemonicSecret to build the prover
    ```

2.  **Configuration Files**: Use a configuration file (e.g., `.properties`, `.yaml`) that is loaded at runtime. **Crucially, this file must NOT be checked into version control.** Add it to your `.gitignore` file.

3.  **Secret Management Services**: For production systems, use a dedicated secrets manager like [HashiCorp Vault](https://www.vaultproject.io/), [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/), or [Google Secret Manager](https://cloud.google.com/secret-manager). Your application would fetch the mnemonic from the service at startup using a secure, authenticated API call.

Always validate untrusted input, such as addresses or amounts coming from user interfaces, to prevent scams or accidental fund loss.


## Input Schema

```json
{
  "type": "object",
  "properties": {},
  "required": [
    "command",
    "network_type",
    "node_url"
  ]
}
```

## Output Schema

```json
{
  "properties": {},
  "type": "object",
  "required": [
    "generated_code",
    "language"
  ]
}
```

## Examples

### Generate a Java code snippet to connect to a public Ergo Mainnet node.

**Input:**
```json
{}
```

**Output:**
```json
{}
```

### Generate Java code to send 0.1 ERG on Testnet using a mnemonic stored securely.

**Input:**
```json
{}
```

**Output:**
```json
{}
```

### Generate Java code to issue 1,000,000 new custom tokens on Testnet.

**Input:**
```json
{}
```

**Output:**
```json
{}
```

## Permissions

- `codegeneration:create:java`
- `blockchain:ergo:read`
- `secret:read:walletMnemonic`

## Constraints

- Rate Limit: 20 requests per minute
- Maximum payload size: 64KB
- Timeout: 30 seconds

